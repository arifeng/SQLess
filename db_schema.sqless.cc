
// Generated by SQLess v0.1

#include "db_schema.sqless.h"

#include <sstream>

namespace {

std::string &TrimRight(std::string &s, const std::string &m) {
    size_t pe = s.length() - 1;
    while (pe < s.length() && m.find(s.at(pe)) != m.npos)
        pe--;

    if (pe >= s.length())
        return s.erase(0, s.length());

    return s.erase(pe + 1, s.length() - 1 - pe);
}

}

namespace ns {

SqlessConn::SqlessConn() {
}

SqlessConn::~SqlessConn() {
    if (database_db1_)
        delete database_db1_;

    close();
}

bool SqlessConn::connect(const std::string& path, const std::string& key /* = "" */) {
    if (sqlite3_open(path.c_str(), &handle_) != SQLITE_OK)
        return false;

    return true;
}

bool SqlessConn::isValid() {
    return handle_ != NULL;
}

void SqlessConn::beginTransition() {
    sqlite3_exec(handle_, "BEGIN;", NULL, NULL, NULL);
}

void SqlessConn::endTransition() {
    sqlite3_exec(handle_, "COMMIT;", NULL, NULL, NULL);
}

void SqlessConn::close() {
    sqlite3_close(handle_);
}

bool SqlessConn::has_database_db1() {
    return true;
}

SqlessDB_db1 *SqlessConn::database_db1() {
    if (!database_db1_)
        database_db1_ = new SqlessDB_db1(this);

    return database_db1_;
}

const char SqlessDB_db1::kName[] = "db1";
const char SqlessDB_db1::kDescription[] = "a test database";

SqlessDB_db1::SqlessDB_db1(SqlessConn* conn)
    :conn_(conn) {

    if (!exists())
        create();
}

SqlessDB_db1::~SqlessDB_db1() {
    if (table_tb1_)
        delete table_tb1_;

}

bool SqlessDB_db1::exists() {
    return true;
}

void SqlessDB_db1::drop() {

}

bool SqlessDB_db1::execQuery(const std::string& sql_stmt) {
    use();
    return sqlite3_exec(conn_->handle(), sql_stmt.c_str(), NULL, NULL, NULL) == SQLITE_OK;
}

bool SqlessDB_db1::create() {
    return true;
}

bool SqlessDB_db1::use() {
    return true;
}

bool SqlessDB_db1::has_table_tb1() {
    std::string sql = "SELECT name FROM sqlite_master WHERE type = \"table\" AND name = \"tb1\";";

    sqlite3_stmt* stmt = NULL;
    if (sqlite3_prepare_v2(conn_->handle(), sql.c_str(), -1, &stmt, 0) != SQLITE_OK) {
        const char* s = sqlite3_errmsg(conn_->handle());
        return false;
    }

    bool exists = false;
    if (sqlite3_step(stmt) == SQLITE_ROW)
        exists = true;

    sqlite3_finalize(stmt);
    return exists;
}

SqlessTable_tb1* SqlessDB_db1::table_tb1() {
    if (!table_tb1_)
        table_tb1_ = new SqlessTable_tb1(this);

    return table_tb1_;
}

const char SqlessTable_tb1::kName[] = "tb1";
const char SqlessTable_tb1::kDescription[] = "a test table";

SqlessTable_tb1::SqlessTable_tb1(SqlessDB_db1* db)
    :db_(db) {
    if (!exists())
        create();
}

SqlessTable_tb1::~SqlessTable_tb1() {
}

bool SqlessTable_tb1::exists() {
    return db_->has_table_tb1();
}

bool SqlessTable_tb1::create() {
    return db_->execQuery("CREATE TABLE tb1 (
col1 INTEGER PRIMARY_KEY AUTOINCREMENT,
col2 REAL DEFAULT 0,
col3 TEXT DEFAULT 'hahaha',
col4 BLOB,
);");
}

bool SqlessTable_tb1::drop() {
    return db_->execQuery("DROP TABLE IF EXISTS \"tb1\";");
}

int SqlessTable_tb1::row_count() {
    //TODO: 计算表行数
    return 0;
}

} // namespace ns

